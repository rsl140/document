## 冒泡排序

  > 时间复杂度 0(n^2)

  ``` js
  Array.prototype.bubbleSort = function () {
    for (let i = 0; i < this.length - 1; i++) {
      for (let j = 0; j < this.length - 1 - i; j++) {
        if (this[j] > this[j + 1]) {
          const temp = this[j]
          this[j] = this[j + 1]
          this[j + 1] = temp
        }
      }
    }
  }
  ```

## 选择排序

  > 时间复杂度 0(n^2)

  ``` js
  Array.prototype.selectSort = function () {
    for (let i = 0; i < this.length - 1; i++) {
      let indexMin = i
      for (let j = i; j < this.length; j++) {
        if (this[j] < this[indexMin]) {
          indexMin = j
        }
      }

      // 交换位置不一致才需要交换
      if ( i !== indexMin) {
        const temp = this[i]
        this[i] = this[indexMin]
        this[indexMin] = temp
      }
    }
  }
  ```

## 插入排序

  > 时间复杂度 0(n^2)

  ``` js
  Array.prototype.insertionSort = function () {
    for (let i = 1; i < this.length; i++) {
      let temp = this[i]
      let j = i
      while (j > 0) {
        if (this[j - 1] > temp) {
          this[j] = this[j - 1]
        } else {
          break
        }
        j--
      }
      this[j] = temp
    }
  }
  ```

## 归并排序

  > 时间复杂度 0(n*logN)

  ``` js
  Array.prototype.mergeSort = function () {
    const rec = (arr) => {
      if (arr.length === 1) { return arr}
      const mid = Math.floor(arr.length / 2)
      const left = arr.slice(0, mid)
      const right = arr.slice(mid)
      const orderLeft = rec(left)
      const orderRight = rec(right)
      const res = []
      while (orderLeft.length || orderRight.length) {
        if (orderLeft.length && orderRight.length) {
          res.push(orderLeft[0] < orderRight[0] ? orderLeft.shift() : orderRight.shift())
        } else if (orderLeft.length) {
          res.push(orderLeft.shift())
        } else if (orderRight.length) {
          res.push(orderRight.shift())
        }
      }
      return res
    }
    const res = rec(this)
    res.forEach((n,i) => {
      this[i] = n
    })
  }
  ```