- 为什么要有异步

  JS是可以去操作DOM的。假设JS设计成一个多线程语言。你的主线程在给DOM的innerHtml做一个赋值操作，你的另一个线程把这个DOM结构删除了。所以干脆设计成一个单线程。

  但是浏览器加载一些需要网络请求的比如图片资源、ajax。或者轮训的内容。由于是单线程，需要等待这些内容访问完才可以执行下面的代码。那么你发个ajax请求或者请求个图片资源，那么这段时间就什么也做不了，这种效果对程序是一种阻塞，在等待时间明明可以做些别的事情却选择了无意义的等待。（同步阻塞）这个时候异步就出现了，在涉及需要等待的操作，我们选择让程序继续运行，在等待时间结束的时候，通知一下我们的程序内容执行完毕，你可以操作这些资源了，这段等待时间并不影响你程序的继续执行，只是在未来的某个时间段（不确定），有一个操作一定会执行，这就是异步。（异步非阻塞），这就是为什么要有同步异步

- 宏任务，微任务

  常见的宏任务：setTimeout、setInterval（定时器类）

  常见的微任务：promise

  ``` js
  setTimeout(()=>{console.log(111)},0)

  let promise = new Promise((resolve,reject)=>{
    console.log(222);
    resolve(3333)
  });

  let promise2 = new Promise((resolve,reject)=>{
    console.log(555);
    resolve(6666)
  });

  setTimeout(()=>{
    console.log(4444);
  },0)

  promise.then(res=>{
    console.log(res);
  });

  promise2.then(res=>{
    console.log(res);
  });

  // 222 555 3333 6666 111 4444
  ```

  首先在call stack中的内容执行完毕后清空，然后 event queue 检查出宏任务和微任务，然后执行所有的微任务，然后执行一个宏任务，之后再次执行所有的微任务。（这里涉及了事件循环）

  即：在主线程任务执行完毕后会把任务队列中的微任务全部执行，然后再执行一个宏任务，这个宏任务执行完再次检查队列内部的微任务，有就全部执行没有就再执行一个宏任务。

  > 最后最后 JS是单线程但是浏览器是多线程。你的异步任务是浏览器开启对应的线程来执行的，最后放入JS引擎中进行执行

- 参考

  [理解JavaScript异步的美妙](https://juejin.cn/post/6844903648162480142)

- 衍生

  [浏览器多线程和js单线程](https://juejin.cn/post/6844903812642111501)